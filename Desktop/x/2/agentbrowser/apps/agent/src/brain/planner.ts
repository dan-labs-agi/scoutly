import OpenAI from 'openai';
import type { Action } from '@agentbrowser/shared';
import { PLANNER_PROMPT } from './prompts.js';
import { BrowserDriver } from '../driver/browser.js';

// Configuration
const PLANNER_CONFIG = {
  DEFAULT_MODEL: process.env.LLM_MODEL || 'gpt-4o-mini',
  TEMPERATURE: 0.7,
  MAX_TOKENS: 2000,
  CONTEXT_WINDOW: 8, // Number of recent interactions to keep in context
  MAX_RETRY_ATTEMPTS: 2,
  RETRY_DELAY: 1000,
};

export class Planner {
  private memory: Array<{ role: 'user' | 'assistant'; content: string; timestamp: number }> = [];
  private driver: BrowserDriver;
  private readonly logger: Console;
  private readonly openai: OpenAI;

  constructor(driver: BrowserDriver, apiKey: string) {
    this.driver = driver;
    this.logger = console;
    this.openai = new OpenAI({ apiKey });
  }

  async plan(prompt: string, apiKey: string, isVoice?: boolean): Promise<Action[]> {
    try {
      // If this is a voice command, transcribe it first
      let actualPrompt = prompt;
      if (isVoice) {
        this.logger.info('Transcribing voice command...');
        actualPrompt = await this.driver.transcribeVoice(prompt, apiKey);
        this.logger.info(`Transcribed voice command: ${actualPrompt}`);
      }

      // Validate prompt
      if (!actualPrompt.trim()) {
        throw new Error('Empty prompt provided');
      }

      // Add to memory
      this.memory.push({ 
        role: 'user', 
        content: actualPrompt, 
        timestamp: Date.now() 
      });

      // Keep memory within context window
      if (this.memory.length > PLANNER_CONFIG.CONTEXT_WINDOW) {
        this.memory = this.memory.slice(-PLANNER_CONFIG.CONTEXT_WINDOW);
      }

      // Get context from memory
      const context = this.memory.map(m => `${m.role === 'user' ? 'User' : 'Assistant'}: ${m.content}`).join('\n');

      // Prepare messages for the AI
      const messages = [
        { role: 'system' as const, content: PLANNER_PROMPT },
        { role: 'user' as const, content: `${context}\n\nTask: ${actualPrompt}` },
      ];

      // Try to get response with retry logic
      let response;
      let attempts = 0;
      let lastError: Error | null = null;

      while (attempts < PLANNER_CONFIG.MAX_RETRY_ATTEMPTS) {
        try {
          response = await this.openai.chat.completions.create({
            model: PLANNER_CONFIG.DEFAULT_MODEL,
            messages: messages,
            temperature: PLANNER_CONFIG.TEMPERATURE,
            max_tokens: PLANNER_CONFIG.MAX_TOKENS,
            // Add response format to encourage structured output
            response_format: { type: "text" }
          });

          break; // Success, exit retry loop
        } catch (error) {
          lastError = error as Error;
          attempts++;
          this.logger.warn(`AI request attempt ${attempts} failed:`, error);
          
          if (attempts < PLANNER_CONFIG.MAX_RETRY_ATTEMPTS) {
            // Wait before retrying
            await new Promise(resolve => setTimeout(resolve, PLANNER_CONFIG.RETRY_DELAY * attempts));
          }
        }
      }

      if (!response) {
        throw new Error(`Failed to get AI response after ${PLANNER_CONFIG.MAX_RETRY_ATTEMPTS} attempts: ${lastError?.message}`);
      }

      const content = response.choices[0]?.message?.content?.trim() || '';
      
      if (!content) {
        throw new Error('AI returned empty response');
      }

      // Add AI response to memory
      this.memory.push({ 
        role: 'assistant', 
        content: content, 
        timestamp: Date.now() 
      });

      // Parse and validate actions
      const actions = this.parseActions(content);
      
      if (actions.length === 0) {
        this.logger.warn('AI returned no actionable steps');
        throw new Error('No actionable steps generated by AI');
      }

      this.logger.info(`Generated ${actions.length} actions for prompt: ${actualPrompt.substring(0, 50)}...`);
      
      return actions;
    } catch (error) {
      this.logger.error('Error in planning:', error);
      throw new Error(`Planning failed: ${(error as Error).message}`);
    }
  }

  private parseActions(content: string): Action[] {
    const actions: Action[] = [];
    const lines = content.split('\n').map(line => line.trim()).filter(line => line);

    for (const line of lines) {
      try {
        // Parse different action types with strict validation
        let action: Action | null = null;

        // Click action: click(x, y)
        const clickMatch = line.match(/click\(\s*(\d+\.?\d*)\s*,\s*(\d+\.?\d*)\s*\)/i);
        if (clickMatch) {
          const x = parseFloat(clickMatch[1]);
          const y = parseFloat(clickMatch[2]);
          
          // Validate coordinates are within mobile viewport
          if (x >= 0 && x <= 720 && y >= 0 && y <= 1280) {
            action = { type: 'click', x, y };
          } else {
            this.logger.warn(`Invalid click coordinates: (${x}, ${y})`);
          }
        }
        
        // Type action: type("text") or type('text')
        else if (!action) {
          const typeMatch = line.match(/type\(\s*["']([^"']*)["']\s*\)/i);
          if (typeMatch) {
            const text = typeMatch[1];
            // Basic validation to prevent potentially harmful inputs
            if (this.isValidTextForTyping(text)) {
              action = { type: 'type', text };
            } else {
              this.logger.warn(`Invalid text for typing: ${text.substring(0, 20)}...`);
            }
          }
        }
        
        // Scroll action: scroll(dx, dy)
        else if (!action) {
          const scrollMatch = line.match(/scroll\(\s*(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)\s*\)/i);
          if (scrollMatch) {
            const dx = parseFloat(scrollMatch[1]);
            const dy = parseFloat(scrollMatch[2]);
            
            // Validate scroll values are reasonable (not too large)
            if (Math.abs(dx) <= 10000 && Math.abs(dy) <= 10000) {
              action = { type: 'scroll', dx, dy };
            } else {
              this.logger.warn(`Invalid scroll values: (${dx}, ${dy})`);
            }
          }
        }
        
        // Navigation action: nav("url") or nav('url')
        else if (!action) {
          const navMatch = line.match(/nav\(\s*["']([^"']*)["']\s*\)/i);
          if (navMatch) {
            const url = navMatch[1];
            if (this.isValidUrl(url)) {
              action = { type: 'nav', url };
            } else {
              this.logger.warn(`Invalid navigation URL: ${url}`);
            }
          }
        }
        
        // Wait action: wait(milliseconds)
        else if (!action) {
          const waitMatch = line.match(/wait\(\s*(\d+)\s*\)/i);
          if (waitMatch) {
            const ms = parseInt(waitMatch[1], 10);
            // Validate wait time is reasonable (max 30 seconds)
            if (ms >= 0 && ms <= 30000) {
              action = { type: 'wait', ms };
            } else {
              this.logger.warn(`Invalid wait time: ${ms}ms`);
            }
          }
        }

        // Add action if successfully parsed
        if (action) {
          actions.push(action);
        } else {
          // Log unparsable lines but don't throw error - they might be comments
          this.logger.debug(`Unparsable line (not an action): ${line}`);
        }
      } catch (parseError) {
        this.logger.warn(`Error parsing action line "${line}":`, parseError);
        // Continue to next line instead of failing entire parsing
      }
    }

    return actions;
  }

  private isValidUrl(url: string): boolean {
    try {
      // Basic security check: only allow http/https URLs
      const lowerUrl = url.toLowerCase();
      if (!lowerUrl.startsWith('http://') && !lowerUrl.startsWith('https://')) {
        // Allow relative URLs and special browser URLs like about:blank
        if (!/^[a-z][a-z0-9+.-]*:/.test(url) || lowerUrl.startsWith('about:')) {
          return true;
        }
        return false;
      }
      
      // Use URL constructor to validate
      new URL(url);
      return true;
    } catch {
      return false;
    }
  }

  private isValidTextForTyping(text: string): boolean {
    // Basic validation to prevent harmful inputs
    // - No script tags
    // - No excessive length
    // - No potentially harmful commands
    
    if (text.length > 1000) {
      return false; // Too long
    }
    
    const lowerText = text.toLowerCase();
    
    // Check for potentially harmful patterns
    const harmfulPatterns = [
      '<script',
      'javascript:',
      'vbscript:',
      '<iframe',
      '<object',
      '<embed',
      'alert(',
      'prompt(',
      'confirm(',
    ];
    
    return !harmfulPatterns.some(pattern => lowerText.includes(pattern));
  }

  // Clear memory - useful for session management
  clearMemory(): void {
    this.memory = [];
  }

  // Get current memory size
  getMemorySize(): number {
    return this.memory.length;
  }
}
